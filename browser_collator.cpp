#include "browser_collator.h"
#include "player_logger.h"

#if defined USE_ICU_LIB
    #include <unicode/ucol.h>
    #include <unicode/utypes.h>
#else//if defined USE_BOOST_LOCALE_LIB
    #include <locale>
    #include <boost/locale.hpp>
    #include <boost/locale/generator.hpp>
#endif

namespace lge {
namespace mm {

BrowserCollator* BrowserCollator::mInstance = NULL;

/**
 * ================================================================================
 * @fn : getInstance
 * @brief : return pointer to BrowserCollator instance.
 * @section : Function flow (Pseudo-code or Decision Table)
 * - return the pointer to BrowserCollator instance.
 * - if the instance does not exists, it creates new instance and return the pointer of new instance.
 * @section Global Variables: none
 * @section Dependencies: none
 * @return ponter to BrowserCollator instance.
 * ===================================================================================
 */
BrowserCollator *BrowserCollator::getInstance()
{
    if(!mInstance)
    {
        mInstance = new BrowserCollator;
    }
    return mInstance;
}

/**
 * ================================================================================
 * @fn : setLocale
 * @brief : apply locale setting.
 * @section : Function flow (Pseudo-code or Decision Table)
 * - call initCollator().
 * @section Global Variables: none
 * @section Dependencies: none
 * @return : bool (result of calling initCallater() )
 * ===================================================================================
 */

bool BrowserCollator::setLocale(std::string locale)
{
    MMLogInfo("'locale = %s", locale.c_str());
    return initCollator(locale);

}


/**
 * ================================================================================
 * @fn : ~BrowserCollator
 * @brief : destructor of BrowserCollator class.
 * @section : Function flow (Pseudo-code or Decision Table)
 * - none
 * @section Global Variables: none
 * @section Dependencies: none
 * @return : none
 * ===================================================================================
 */
BrowserCollator::~BrowserCollator()
{

}

/**
 * ================================================================================
 * @fn : BrowserCollator
 * @brief : constructor of BrowserCollator class.
 * @section : Function flow (Pseudo-code or Decision Table)
 * - get system locale setting.
 * - call initCollator() with system locale.
 * @section Global Variables: none
 * @section Dependencies: none
 * @return : none
 * ===================================================================================
 */
BrowserCollator::BrowserCollator()
    :mCollator(NULL),
      mLocale(std::string())
{
    MMLogInfo("'START");
//    std::string locale = QLocale::system();
    std::string localeString = std::string(setlocale(LC_ALL, NULL));
    MMLogInfo("'LOCALE = %s", localeString.c_str());
    initCollator(localeString);//TO-DO:need read from persistance.
}

/**
 * ================================================================================
 * @fn : initCollator
 * @brief : initialize ICU collator with input locale setting.
 * @section : Function flow (Pseudo-code or Decision Table)
 * - Create RuleBasedCollator instance with locale "zh_CN" for pinyin sorting of hanji.
 * - Get collation rule from RuleBasedCollagor.
 * - if locale is "zh_CN", use constReorderRuleZhCN and constChineseLatinMixRule.
 * - else if locale is "en_US", use constReorderRuleEnUS rule.
 * - Create new RuleBasedCollator with the rule generated by the locale.
 * - save locale to member variable(mLocale).
 * @param[in] locale["zh_CN","en_US"] : locale string
 * @section Global Variables: none
 * @section Dependencies: none
 * @return : bool (TRUE:Success False: Error or Fail)
 * ===================================================================================
 */
#if defined USE_ICU_LIB
bool BrowserCollator::initCollator(std::string locale)
{
    MP_HIGH << "Using ICU lib for collation locale = " << locale << LOG_ENDL;

    UErrorCode status = U_ZERO_ERROR;
    //Because of chinese pinyin rule, use zh_CN collation and reoder script by each language.
    RuleBasedCollator* coll = (RuleBasedCollator*) Collator::createInstance(Locale("zh", "CN"), status);
    if(!U_SUCCESS(status)) {
        MP_LOG << "Create Instance Fail = " << status << LOG_ENDL;
        delete coll;
        return false;
    }

    UnicodeString rule = coll->getRules();
    delete coll;

    if (locale == "zh_CN")
    {
        rule += constReorderRuleZhCN;
        rule += constChineseLatinMixRule;
    }
    else if (locale == "en_US")
    {
        rule += constReorderRuleEnUS;
    }

    mCollator = new RuleBasedCollator(rule, status);
    if(!U_SUCCESS(status)) {
        MP_LOG<< "Create RuleBasedCollator Fail = " << status << LOG_ENDL;
        delete mCollator;
        return false;
    }
    mLocale = locale;
    return true;
}

#else // defined USE_BOOST_LOCALE_LIB
bool BrowserCollator::initCollator(std::string locale)
{
   //locale setting
   //use same local library with media-manager for same sort order.

    MMLogInfo("'Using BOOST lib for collation locale = = %s", locale.c_str());
    boost::locale::generator gen;
    if(locale.empty())
    {
        std::locale::global(gen("")); //get system setting.
    }
    else
    {
        std::string fullLocale = locale + ".UTF-8";
        std::locale::global(gen(fullLocale));
    }
    mLocale = locale;
    return true;
}

#endif
/**
 * ================================================================================
 * @fn : sqlite3LocaleCompare
 * @brief : collator function for sqlite DB, using ICU library.
 * @section : Function flow (Pseudo-code or Decision Table)
 * - Create UnicodeString from data1
 * - Create UnicodeString from data2
 * - Compare two UnicodeString.
 * @param[in] first parameter is not used.
 * @param[in] len1 : length of data1.
 * @param[in] data1 : first source string to compare.
 * @param[in] len2 : lengh of data2.
 * @param[in] data2 : second source string to compare.
 * @section Global Variables: none
 * @section Dependencies: none
 * @return : UCollationResult (UCOL_LESS:data1 < data2, UCOL_GREATER:data1>data2, UCOL_EQUAL:data1 == data2)
 * ===================================================================================
 */
#if defined USE_ICU_LIB
int BrowserCollator::sqlite3LocaleCompare(void *, int len1, const void *data1,
                                          int len2, const void *data2)
{
    UnicodeString ustr1 ((const char*) data1, len1);
    UnicodeString ustr2 ((const char*) data2, len2);;

    UErrorCode status = U_ZERO_ERROR;
    UCollationResult result = getInstance()->getCollator()->compare(ustr1, ustr2, status);
    if(!U_SUCCESS(status))
    {
        MP_LOG << "ERROR" << LOG_ENDL;
    }
    return result;
}

#else // defined USE_BOOST_LOCALE_LIB
int BrowserCollator::sqlite3LocaleCompare(void *, int len1, const void *data1,
                                          int len2, const void *data2)
{
    std::string string1( (const char*) data1, len1);
    std::string string2( (const char*) data2, len2);
    std::locale loc;

    if (loc.operator() (string1, string2))
        return -1;
    else if (loc.operator() (string2, string1))
        return 1;
    else
        return 0;
}

#endif
/**
 * ================================================================================
 * @fn : localeCompare
 * @brief : compare two UnicodeString.
 * @section : Function flow (Pseudo-code or Decision Table)
 * - Compare two UnicodeString with ICU RuleBasedCollator()
 * @param[in] s1 : UnicodeString containing unicode based string.
 * @param[in] s2 : UnicodeString containing unicode based string.
 * @section Global Variables: none
 * @section Dependencies: none
 * @return : UCollationResult (UCOL_LESS:data1 < data2, UCOL_GREATER:data1>data2,
 *           UCOL_EQUAL: data1 == data2  or no collator exists.)
 * ===================================================================================
 */
int BrowserCollator::localeCompare(UnicodeString s1, UnicodeString s2)
{
    if(getInstance() && getInstance()->getCollator())
        return getInstance()->getCollator()->compare(s1, s2);
    else
      return 0;
}

}
}
